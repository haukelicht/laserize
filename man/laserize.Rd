% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/laserize.R
\name{laserize}
\alias{laserize}
\title{Obtain LASER embedding vectors for sentences/texts}
\usage{
laserize(
  x,
  check.languages = TRUE,
  .py.venv = Sys.getenv("RETICULATE_PYTHON_ENV"),
  simplify = FALSE,
  .init.python = TRUE
)
}
\arguments{
\item{x}{a \code{data.frame}, \code{\link[data.table]{data.table}}, or \code{\link[tibble]{tibble}} with columns
\describe{
    \item{id}{character, factor, or numeric; (unique) identifier of sentences/texts}
    \item{text}{character; the actual text to be embeded}
    \item{lang}{character; ISO 639-1 (two-character) code of source language of \code{text}}
}}

\item{check.languages}{logical specifying whether or not to check if all languages in \code{x}
(i.e., \code{unique(x$lang)}) are available through LASER.
Defaults to \code{FALSE}.}

\item{.py.venv}{character (optional), specifying path to a Python virtual environment to be used.
Defaults to \code{NULL} in which case the user's/systems default Python environment is used
(see \code{py_config()}).}

\item{simplify}{logical determining the return value (see below).
\itemize{
  \item{
    If \code{FALSE} (the default), sentence embeddings are returned as a
    named (nested) \code{list} object.
    List element names correspond to \code{x$id}.
    Each list element, in turn, is a \code{list} object with the following elements:
    \describe{
      \item{id}{The sentence/text id (see \code{x})}
      \item{text}{The sentence/text (see \code{x})}
      \item{lang}{The sentence/text language code (see \code{x})}
      \item{e}{The sentence/text LASER embedding vector (type \code{double} with 1024 elements, one for each dimension of the embedding space)}
    }
  }
  \item{
    If \code{TRUE}, sentence/text embeddings are returned as a
    \code{matrix} with \emph{n} rows (i.e., number of sentences in \code{x}, \code{nrow(x)})
    and 1024 columns (the dimensionality of the embedding space), and matrix rows
    named like \code{x$id}.
  }
}}

\item{.init.python}{logical. Passed to \code{\link[reticulate]{py_available}}'s \code{initialize}}
}
\value{
a \code{matrix} or a \code{list}, depending on value passed to argument \code{simplify}.
}
\description{
Function provides an interface to \code{embed_sentences} provided
     through the Python \bold{laserembeddings} module (\url{https://pypi.org/project/laserembeddings/})
}
\note{
Using \code{laserize} presupposes that you have both Python 3 and the \code{laserembeddings} Python module installed.
    If you are not sure whether or not this applies to your system, run \code{\link{setup_laser}}.
}
\section{Checking language codes}{

    Note that setting \code{check.languages = TRUE} triggers an interactive prompt message
    when there is a text in the input data frame with a language that is not supported by LASER.
    To check this manually, pass \code{x$lang} to \code{\link{check_laser_language}}.
}

\section{Out-of-memory problems}{

    Note that for each sentence/text (row) in \code{x}, \code{laserize} obtains a numeric vector of length 1024.
    Given that for each row you thus obtain an object of (1024 times 8 bytes) 8.192 kilobytes (KB),
    obtaining many sentence/text representations at once can quickly cause out-of-memory problems.

    This can be avoided by simply splitting the input data frame passed to argument \code{x} in fixed-size batches (say 100'000 rows),
    and, while iterating over batches, by either appending the output into a \code{\link[data.table]{data.table}} or by writing it to disk.
}

\examples{
\dontrun{
  test_df <- tibble::tribble(
    ~id, ~text, ~lang,
    001, "Hallo Welt", "de",
    002, "Auf wiedersehen", "de",
    003, "Hello world", "en",
    004, "XXGWRXYYFGEG", "unkown",
  )

  res <- laserize(test_df)
  str(res, 1) # name list with four elements
  str(res[[1]], 1) # list with elements 'id', 'text', 'lang', and 'e'

  # simplified output
  res <- laserize(test_df, simplify = TRUE)
  is.matrix(res) # a matrix
  # rows as many as sentences in 'test_df',
  # columns as many as embedding dimensions
  dim(res)

  # check sentence similarities
  cosine_sim <- function(x, y) sum(x*y)/sqrt(sum(x**2)*sum(y**2))
  # representations of greetings in German and English are very similar
  cosine_sim(x = res[1, ], y = res[3, ])
  # representations of German greeting and goodbye are somewhat dissimilar
  cosine_sim(x = res[1, ], y = res[2, ])
}
}
